<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI时代保持自我更新:我的知识库与 Cursor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;600;700;800&display=swap');
        
        :root {
            --font-sans: 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;

            --color-text-primary: #111827;    /* Gray 900 */
            --color-text-secondary: #4b5563; /* Gray 600 */
            --color-bg-primary: #ffffff;
            --color-bg-secondary: #f9fafb;   /* Gray 50 */
            --color-border: #e5e7eb;         /* Gray 200 */
            --color-accent: #2563eb;         /* Blue 600 */
            --color-accent-light: #dbeafe;    /* Blue 100 */
            --color-success: #10b981;        /* Green 500 */
            --color-success-light: #d1fae5;   /* Green 100 */
            --color-warning: #f59e0b;        /* Amber 500 */
            --color-warning-light: #fef3c7;   /* Amber 100 */

            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: var(--font-sans);
            line-height: 1.7;
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            margin: 0;
            padding: 2rem 1rem;
        }
        .wrapper {
            max-width: 1024px;
            margin: auto;
            background: var(--color-bg-primary);
            border-radius: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            border: 1px solid var(--color-border);
            overflow: hidden;
        }
        header {
            padding: 4rem 2.5rem 2rem;
            text-align: center;
            color: var(--color-text-primary);
            border-bottom: 1px solid var(--color-border);
        }
        header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin: 0 0 0.75rem 0;
            letter-spacing: -0.02em;
        }
        header p {
            font-size: 1.1rem;
            color: var(--color-text-secondary);
            max-width: 700px;
            margin: 0 auto;
        }
        .tabs {
            display: flex;
            justify-content: center;
            background-color: var(--color-bg-primary);
            padding: 0 2.5rem;
            border-bottom: 1px solid var(--color-border);
        }
        .tab-button {
            padding: 1rem 1.5rem;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 1rem;
            font-weight: 600;
            color: var(--color-text-secondary);
            position: relative;
            transition: color 0.2s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px; /* Overlap container border */
        }
        .tab-button.active {
            color: var(--color-accent);
            border-bottom-color: var(--color-accent);
        }
        .tab-button:hover:not(.active) {
            color: var(--color-text-primary);
        }
        .tab-button::after {
            content: none;
        }
        .tab-content {
            display: none;
            padding: 2.5rem;
        }
        .tab-content.active {
            display: block;
        }
        .card {
            background: var(--color-bg-primary);
            border: none;
            border-radius: 1rem;
            padding: 0;
            margin-bottom: 2.5rem;
        }
        .card:not(:last-child) {
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 2.5rem;
        }
        .card h3 {
            font-size: 1.5rem;
            color: var(--color-text-primary);
            margin-top: 0;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }
        .card h3 .icon {
            margin-right: 12px;
            font-size: 1.5rem;
            color: var(--color-accent);
        }
        .visualization-list {
            list-style: none;
            padding-left: 0;
            margin-top: 1.5rem;
        }
        .visualization-list li {
            margin-bottom: 1rem;
            font-size: 1rem;
            display: flex;
            align-items: center;
        }
        .visualization-list .icon {
            margin-right: 10px;
            font-size: 1.2rem;
            color: var(--color-accent);
        }
        .visualization-list a {
            text-decoration: none;
            color: var(--color-accent);
            font-weight: 500;
        }
        .visualization-list a:hover {
            text-decoration: underline;
        }
        .avatar-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
            padding: 1rem;
            background: var(--color-bg-secondary);
            border-radius: 8px;
        }
        .avatar-placeholder {
            /* Unchanged, as it's for the generator itself */
        }
        .demo-box {
            background-color: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            padding: 1.5rem;
            border-radius: 12px;
            margin-top: 1.5rem;
        }
        .demo-box .title {
            color: var(--color-text-primary);
            font-weight: 700;
            font-size: 1.1rem;
            margin: 0 0 1rem 0;
        }
        .demo-box .prompt {
            color: var(--color-text-secondary);
            font-style: normal;
            font-weight: 500;
            background: var(--color-bg-primary);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            display: block;
            border: 1px solid #d1d5db; /* Gray 300 */
            font-family: var(--font-mono);
        }
        #generate-avatar-btn {
            margin-top: 1rem; padding: 0.6rem 1.2rem; font-size: 1rem; background-color: var(--color-accent); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: background-color 0.2s;
        }
        #generate-avatar-btn:hover { background-color: #1d4ed8; /* Blue 700 */ }
        
        footer {
            text-align: center;
            padding: 2rem;
            background: var(--color-bg-secondary);
            color: var(--color-text-secondary);
            font-size: 0.95rem;
        }

        /* Houdini Demo Styles */
        .vex-demo .demo-container { display: flex; gap: 1.5rem; margin-top: 1.5rem; min-height: 350px; }
        .vex-demo .viewport-container { flex: 3; background-color: var(--color-bg-secondary); border-radius: 8px; overflow: hidden; position: relative; }
        .vex-demo .controls-container { flex: 2; display: flex; flex-direction: column; gap: 1rem; }
        .vex-demo .code-block { background-color: #2d333b; color: #c9d1d9; padding: 1rem; border-radius: 6px; font-family: var(--font-mono); font-size: 0.9rem; white-space: pre-wrap; flex-grow: 1; }
        .vex-demo .code-block .comment { color: #8b949e; } .vex-demo .code-block .type { color: #ffa657; } .vex-demo .code-block .function { color: #d2a8ff; } .vex-demo .code-block .variable { color: #79c0ff; }
        .vex-demo .sliders { background: var(--color-bg-primary); padding: 1rem; border-radius: 6px; }
        .vex-demo .sliders label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
        .vex-demo .sliders input[type="range"] { width: 100%; margin-bottom: 1rem; }
        @media (max-width: 768px) { .vex-demo .demo-container { flex-direction: column; } }

        /* Health Demo Styles */
        .health-container { display: flex; gap: 2rem; margin-top: 1.5rem; padding: 1.5rem; background: var(--color-bg-primary); border-radius: 12px; }
        .report-side, .advice-side { flex: 1; min-width: 0; }
        .report-side h4, .advice-side h4 { font-size: 1.2rem; font-weight: 700; margin-top: 0; margin-bottom: 1.5rem; border-bottom: 2px solid; padding-bottom: 0.5rem; }
        .report-side h4 { color: var(--color-accent); border-color: var(--color-accent-light); }
        .advice-side h4 { color: var(--color-success); border-color: var(--color-success-light); }
        .report-side h5, .advice-side h5 { font-size: 1.05rem; font-weight: 700; color: var(--color-text-primary); margin-bottom: 1rem; }
        .health-indices ul, .advice-side ul { list-style: none; padding: 0; margin: 0; }
        .health-indices li { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0.2rem; border-bottom: 1px solid var(--color-border); font-size: 0.95rem; }
        .health-indices .index-name { font-weight: 500; color: var(--color-text-secondary); }
        .health-indices .index-value { font-weight: bold; padding: 0.2rem 0.6rem; border-radius: 12px; font-size: 0.9rem; background-color: var(--color-bg-secondary); color: var(--color-text-secondary); }
        .health-indices .index-value.attention { background-color: var(--color-warning-light); color: var(--color-warning); }
        .imaging-reports { margin-top: 2rem; }
        .report-item { margin-bottom: 1.5rem; }
        .report-item h6 { font-size: 1rem; font-weight: 700; margin: 0 0 0.7rem 0; }
        .report-image-placeholder { width: 100%; height: 150px; background: var(--color-bg-secondary); border-radius: 8px; display: flex; justify-content: center; align-items: center; color: #9ca3af; font-style: italic; border: 2px dashed #d1d5db; }
        .report-text { font-size: 0.95rem; background: #fff; border: 1px solid var(--color-border); padding: 0.8rem 1rem; border-radius: 6px; line-height: 1.6; color: var(--color-text-secondary); }
        .advice-section { margin-bottom: 1.5rem; }
        .advice-side li { display: flex; align-items: flex-start; margin-bottom: 1.2rem; font-size: 0.95rem; line-height: 1.6; color: var(--color-text-secondary); }
        .advice-icon { font-size: 1.2rem; margin-right: 0.8rem; margin-top: 2px; }
        @media (max-width: 860px) { .health-container { flex-direction: column; } }

        /* --- Embedded Demo Styles --- */
        .embedded-demo { margin-top: 2rem; padding: 1.5rem; border-radius: 12px; background: var(--color-bg-secondary); border: 1px solid var(--color-border); }
        .embedded-demo h4 { font-size: 1.3rem; color: var(--color-text-primary); margin-top: 0; margin-bottom: 1.5rem; text-align: center; }
        .kl-demo .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .kl-demo .input-group { padding: 1rem; border: 1px solid var(--color-border); border-radius: 8px; }
        .kl-demo .input-group legend { font-weight: bold; color: var(--color-text-secondary); padding: 0 8px; font-size: 0.95rem; }
        .kl-demo .input-group label { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; font-size: 0.9rem; }
        .kl-demo .input-group input[type="range"] { flex-grow: 1; margin: 0 10px; }
        .kl-demo .chart-container-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 320px; }
        .kl-demo .chart-container { position: relative; height: 100%; width: 100%; }
        .kl-demo .result { margin-top: 20px; font-size: 1rem; line-height: 1.7; text-align: center; background: #fff; padding: 0.8rem; border-radius: 8px;}
        .kl-demo .highlight { color: var(--color-accent); font-weight: bold; }
        .kl-demo .math-formula { font-family: 'Times New Roman', serif; font-style: italic; }
        .kl-demo .math-subscript { font-size: 0.8em; vertical-align: sub; }

        .mc-demo .simulation-area { display: flex; gap: 20px; align-items: flex-start; }
        .mc-demo .canvas-container { flex: 1; text-align: center; }
        .mc-demo canvas { border: 2px solid var(--color-border); border-radius: 8px; background: #fff; }
        .mc-demo .controls { flex: 1; }
        .mc-demo .stats { background: var(--color-text-primary); color: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem; font-size: 0.9rem; }
        .mc-demo .stat-item { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .mc-demo .stat-value { font-weight: bold; color: var(--color-warning); }
        .mc-demo .controls button { background: linear-gradient(45deg, #FF6B6B, #4ECDC4); color: white; border: none; padding: 8px 16px; font-size: 0.9rem; border-radius: 20px; cursor: pointer; margin: 5px; transition: all 0.3s ease; font-weight: bold; box-shadow: var(--shadow-sm); }
        .mc-demo .controls button:hover { transform: translateY(-2px); box-shadow: var(--shadow-md); }
        .mc-demo .speed-control { margin: 1rem 0; }
        .mc-demo .speed-control label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--color-text-secondary); font-size: 0.9rem; }
        .mc-demo .speed-control input { width: 100%; }
        @media (max-width: 900px) { .kl-demo .input-grid, .kl-demo .chart-container-grid { grid-template-columns: 1fr; } .kl-demo .chart-container-grid { height: auto; } .kl-demo .chart-container { height: 250px; margin-bottom: 1rem; } }
        @media (max-width: 768px) { .mc-demo .simulation-area { flex-direction: column; } }
    </style>
</head>
<body>

    <div class="wrapper">
        <header>
            <h1>知识库笔记与 Cursor 💡</h1>
            <p>更新自我思维模型，适应AI时代的个人习惯</p>
        </header>

        <div class="tabs">
            <button class="tab-button active" onclick="openTab(event, 'learning')">🚀 学习</button>
            <button class="tab-button" onclick="openTab(event, 'work')">💼 工作</button>
            <button class="tab-button" onclick="openTab(event, 'life')">❤️ 生活</button>
        </div>

        <div id="learning" class="tab-content active">
            <div class="card">
                <h3><span class="icon">💡</span>个人用笔记来持续学习的原因</h3>
                <p><b>非 AI 时代：</b>内容、工具和理论的变化都相对缓慢。我们记笔记是为了“归档”。</p>
                <p><b>AI 时代：</b>内容和工具在加速迭代。这意味着，<b>学习能力本身，成为了最重要的能力。</b>我的知识库 <code>DyVault</code> 正是为此服务。</p>
                <p><b>未来远景：</b>每一次记录，都是在为自己的<b>“数字分身”</b>提供养料。随着未来 AI 模型训练门槛的降低，这些结构化的思考和知识，将是复刻我们思维模式的宝贵数据。</p>
            </div>
            <div class="card">
                <h3><span class="icon">🔬</span>实践：将抽象理论“具象化”</h3>
                <p><b>痛点：</b>面对复杂的前沿理论（如 AI 原理、数学概念）时，往往难以理解。</p>
                <p><b>方法：</b>利用 AI 的“翻译”能力，将复杂的概念用我能理解的比喻和方式重新解释，并存入笔记，如 <code>Notes/DeepLearn/KL.md</code>。</p>
                
                <ul class="visualization-list">
                    <li><span class="icon">📈</span><a href="KL.html" target="_blank">KL 散度可视化 (独立页面)</a></li>
                    <li><span class="icon">🎲</span><a href="Monte_Carlo.html" target="_blank">蒙特卡洛方法模拟 (独立页面)</a></li>
                </ul>

                <div class="embedded-demo kl-demo">
                    <h4>KL 散度交互演示</h4>
                    <div class="input-grid">
                        <fieldset class="input-group">
                            <legend>真实分布 p(x)</legend>
                            <label>μ<sub>p</sub>: <input type="range" id="kl-mu_p" min="-2.5" max="2.5" step="0.1" value="0"><span id="kl-mu_p_val">0.0</span></label>
                            <label>σ<sub>p</sub>: <input type="range" id="kl-sigma_p" min="0.2" max="2" step="0.1" value="1"><span id="kl-sigma_p_val">1.0</span></label>
                        </fieldset>
                        <fieldset class="input-group">
                            <legend>近似分布 q(x)</legend>
                            <label>μ<sub>q</sub>: <input type="range" id="kl-mu_q" min="-2.5" max="2.5" step="0.1" value="0.5"><span id="kl-mu_q_val">0.5</span></label>
                            <label>σ<sub>q</sub>: <input type="range" id="kl-sigma_q" min="0.2" max="2" step="0.1" value="1.2"><span id="kl-sigma_q_val">1.2</span></label>
                        </fieldset>
                    </div>
                    <div class="chart-container-grid">
                        <div class="chart-container"><canvas id="kl-pdfChart"></canvas></div>
                        <div class="chart-container"><canvas id="kl-entropyChart"></canvas></div>
                    </div>
                    <div class="result" id="kl-result"></div>
                </div>

                <div class="embedded-demo mc-demo">
                    <h4>蒙特卡洛估算 π</h4>
                    <div class="simulation-area">
                        <div class="canvas-container">
                            <canvas id="mc-simulationCanvas" width="300" height="300"></canvas>
                        </div>
                        <div class="controls">
                            <div class="stats">
                                <div class="stat-item"><span>总点数:</span><span class="stat-value" id="mc-totalPoints">0</span></div>
                                <div class="stat-item"><span>圆内点数:</span><span class="stat-value" id="mc-insidePoints">0</span></div>
                                <div class="stat-item"><span>估算 π 值:</span><span class="stat-value" id="mc-estimatedPi">0.0000</span></div>
                            </div>
                            <div class="speed-control">
                                <label>模拟速度:</label>
                                <input type="range" id="mc-speedSlider" min="1" max="100" value="50">
                            </div>
                            <button id="mc-startBtn">🚀 开始</button>
                            <button id="mc-pauseBtn">⏸️ 暂停</button>
                            <button id="mc-resetBtn">🔄 重置</button>
                            <button id="mc-batchBtn">➕ 批量(1k)</button>
                        </div>
                    </div>
                </div>

                <div class="demo-box">
                    <div class="title">🎬 现场挑战: 化繁为简</div>
                    <p><strong>场景:</strong> 我想让设计师同事也能秒懂“KL散度”。</p>
                    <p class="prompt">@file:Notes/DeepLearn/KL.md 我是一个设计师，请用一个关于“两张设计稿差异”的比喻，向我解释这个文档里提到的“KL散度”是什么。</p>
                </div>
            </div>
        </div>

        <div id="work" class="tab-content">
            <div class="card">
                <h3><span class="icon">🛠️</span>实践：极速掌握工作新技能</h3>
                <p><b>痛点：</b>工作中需要快速上手一个新软件，比如 Houdini，但官方文档太庞大。</p>
                <p><b>方法：</b>让 Cursor 成为我的“私人教师”，直接针对我的问题给出答案，并将最有价值的信息沉淀到笔记中。例如，这是我的 <a href="Vex.html" target="_blank">Vex 脚本学习笔记</a>。</p>
                
                <div class="demo-box vex-demo" style="margin-top: 2rem;">
                    <div class="title">🎬 VEX 交互演示：程序化圆环</div>
                    <div class="demo-container">
                        <div class="viewport-container" id="houdini-viewport"></div>
                        <div class="controls-container">
                            <div class="code-block">
<pre><code><span class="comment">// VEX code to generate a torus</span>
<span class="comment">// Parameters are controlled by sliders</span>

<span class="type">float</span> <span class="variable">radius</span>    = <span class="function">chf</span>(<span class="string">"radius"</span>);
<span class="type">float</span> <span class="variable">thickness</span> = <span class="function">chf</span>(<span class="string">"thickness"</span>);

<span class="comment">// (Pseudo-code for concept)</span>
<span class="function">addprim</span>(<span class="variable">@OpInput1</span>, <span class="string">"torus"</span>, {
  <span class="string">"radius"</span>: <span class="variable">radius</span>,
  <span class="string">"tube"</span>: <span class="variable">thickness</span>
});</code></pre>
                            </div>
                            <div class="sliders">
                                <label for="radius-slider">圆环半径 (Radius): <span id="radius-value">1.0</span></label>
                                <input type="range" id="radius-slider" min="0.5" max="2" step="0.05" value="1.0">
                                
                                <label for="thickness-slider">管道粗细 (Thickness): <span id="thickness-value">0.4</span></label>
                                <input type="range" id="thickness-slider" min="0.1" max="1" step="0.05" value="0.4">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="demo-box" style="margin-top: 2rem;">
                    <div class="title">🎬 现场挑战: “烹饪”Houdini</div>
                    <p><strong>场景:</strong> 我想快速理解 Houdini 不同工作模块的核心区别。</p>
                    <p class="prompt">我是一个 Houdini 初学者，请用一个关于“做饭”的比喻，解释一下 “SOPs”, “VOPs”, “DOPs” 这三个概念的核心区别是什么？</p>
                </div>
            </div>
            <div class="card">
                <h3><span class="icon">🔄</span>根据笔记内容生成符合需求的任意脚本</h3>
                <p><b>优势：</b>这是飞书等纯文档工具无法比拟的。我可以在笔记里构思，然后立刻让 Cursor 帮我创建项目 Demo 来验证想法。</p>
                <div class="demo-box">
                    <div class="title">🎬 现场挑战: AI 驱动的头像生成器</div>
                    <p><strong>场景:</strong> 我想用 Python 脚本快速生成一系列风格化的游戏头像。</p>
                    <p class="prompt">@file:Avatar.py 请解释这个脚本的核心功能，并说明如何使用它来生成头像。</p>
                    <button id="generate-avatar-btn" style="margin-top: 1rem; padding: 0.6rem 1.2rem; font-size: 1rem; background-color: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer;">点击生成头像</button>
                </div>
                <div class="avatar-preview" id="avatar-canvas">
                    <!-- Avatars will be generated here -->
                </div>
            </div>
            <div class="card">
                <h3><span class="icon">📊</span>根据项目代码快速生成交互demo方便汇报</h3>
                <p>这是一个使用 AI 辅助生成的交互式产品原型，展示了“AI创意总监”的核心工作流程。您可以 <a href="prototype_ui.html" target="_blank">点击此处查看原型</a>。</p>
            </div>
        </div>

        <div id="life" class="tab-content">
            <div class="card">
                <h3><span class="icon">❤️‍🩹</span>实践：将数据转化为生活洞见</h3>
                <p><b>方法：</b>将体检报告等关键健康信息存入笔记，然后让 AI 成为我的“健康管家”，帮我分析并制定可执行的计划。</p>
                
                <div class="health-container">
                    <!-- Left Side: The Report -->
                    <div class="report-side">
                        <h4>📘 我的健康笔记</h4>
                        <div class="health-indices">
                            <h5>关键指标与状态</h5>
                            <ul>
                                <li><span class="index-name">低密度脂蛋白(LDL)</span><span class="index-value attention">偏高</span></li>
                                <li><span class="index-name">体重指数(BMI)</span><span class="index-value attention">25.8</span></li>
                                <li><span class="index-name">睡眠质量</span><span class="index-value">有待改善</span></li>
                            </ul>
                        </div>
                        <div class="imaging-reports">
                            <h5>专项检查记录</h5>
                            <div class="report-item">
                                <h6>胸部检查</h6>
                                <div class="report-image-placeholder">
                                    <span>胸部影像 (示意)</span>
                                </div>
                            </div>
                             <div class="report-item">
                                <h6>胃部检查</h6>
                                <p class="report-text"><strong>结论：</strong>慢性非萎缩性胃炎。建议清淡饮食，规律作息。</p>
                            </div>
                        </div>
                    </div>

                    <!-- Right Side: The AI Advice -->
                    <div class="advice-side">
                        <h4>💡 AI 生活小助手</h4>
                        <div class="advice-section">
                            <h5>综合建议</h5>
                            <ul>
                                <li><span class="advice-icon">🥗</span>注意到您的几项指标需要关注，可以从增加膳食纤维开始，比如多吃蔬菜、用燕麦代替部分主食。</li>
                                <li><span class="advice-icon">👟</span>提高BMI和LDL的“性价比”之王是快走！每天30分钟，对改善指标和胃动力都有好处。</li>
                                <li><span class="advice-icon">��</span>好的睡眠是健康基石。睡前冥想5分钟或听听轻音乐，能有效提升睡眠质量。</li>
                                 <li><span class="advice-icon">🚭</span>胸部检查没发现大问题，但也要保持警惕，远离烟草环境对肺部健康最重要。</li>
                            </ul>
                        </div>
                    </div>
                </div>

                 <div class="demo-box" style="margin-top: 2rem;">
                    <div class="title">🎬 现场挑战: 我的 AI 健康管家</div>
                    <p><strong>场景:</strong> 我想根据体检报告，制定一个简单的健康计划。</p>
                    <p class="prompt">@file:Health/250416.md 基于这份文档中提到的‘低密度脂蛋白偏高’，帮我用 markdown 格式制定一个为期一周的、注重健康饮食和有氧运动的简单计划表。</p>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>选择一个好的工具，本质上是选择一种能放大我们学习能力的思维方式。<br>Cursor + 个人知识库，就是我现阶段找到的最佳答案。</p>
    </footer>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        // This function needs to be global for the onclick="" attribute to work
        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }
    
        document.addEventListener('DOMContentLoaded', () => {
            // --- DEMO INITIALIZATION ---
            const learningTab = document.getElementById('learning');
            const workTab = document.getElementById('work');

            // --- Learning Tab ---
            if (learningTab && learningTab.classList.contains('active')) {
                initLearningTabDemos();
            }

            // --- Work Tab ---
            const initWorkTabDemos = () => {
                // Avatar Demo
                const avatarCanvas = document.getElementById('avatar-canvas');
                if (avatarCanvas && avatarCanvas.offsetParent !== null && !avatarCanvas.dataset.initialized) {
                    avatarCanvas.dataset.initialized = 'true';
                    const generateBtn = document.getElementById('generate-avatar-btn');
                    initAvatarGenerator(generateBtn, avatarCanvas);
                }

                // Houdini Demo
                const houdiniViewport = document.getElementById('houdini-viewport');
                if (houdiniViewport && houdiniViewport.offsetParent !== null && !houdiniViewport.dataset.initialized) {
                    houdiniViewport.dataset.initialized = 'true';
                    initHoudiniDemo();
                }
            };
            
            // Use a single observer for the "Work" tab to initialize all demos within it.
            const workTabObserver = new MutationObserver(() => {
                // When the tab's style changes (e.g., display: block), check to initialize demos.
                initWorkTabDemos();
            });

            if (workTab) {
                workTabObserver.observe(workTab, { attributes: true, attributeFilter: ['style'] });
            }
             // Fallback for cases where the tab is already visible on load
            if (workTab && workTab.classList.contains('active')) {
                // This case is less likely for the work tab unless it's set as default
                initWorkTabDemos();
            }
        });

        function initLearningTabDemos() {
            // Check if already initialized to prevent re-running on tab clicks
            if (document.body.dataset.learningDemosInitialized) return;
            document.body.dataset.learningDemosInitialized = 'true';

            initKLDemo();
            initMonteCarloDemo();
        }

        function initKLDemo() {
            let pdfChartInstance = null;
            let entropyChartInstance = null;
            const inputs = {
                mu_p: document.getElementById('kl-mu_p'), sigma_p: document.getElementById('kl-sigma_p'),
                mu_q: document.getElementById('kl-mu_q'), sigma_q: document.getElementById('kl-sigma_q'),
            };
            const values = {
                mu_p_val: document.getElementById('kl-mu_p_val'), sigma_p_val: document.getElementById('kl-sigma_p_val'),
                mu_q_val: document.getElementById('kl-mu_q_val'), sigma_q_val: document.getElementById('kl-sigma_q_val'),
            };
            const pdfCtx = document.getElementById('kl-pdfChart')?.getContext('2d');
            const entropyCtx = document.getElementById('kl-entropyChart')?.getContext('2d');
            
            if (!pdfCtx || !entropyCtx) return;

            const safeLog = (x) => (x > 0 ? Math.log(x) : -Infinity);
            const entropyDensity = (p, base_p) => (p > 0 ? -p * safeLog(base_p) : 0);

            function normalPDF(x, mu, sigma) {
                return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2));
            }

            function calcMetrics(p, q) {
                const H = 0.5 * Math.log(2 * Math.PI * Math.E * p.sigma * p.sigma);
                const Hpq = 0.5 * Math.log(2 * Math.PI * q.sigma * q.sigma) + (p.sigma * p.sigma + Math.pow(p.mu - q.mu, 2)) / (2 * q.sigma * q.sigma);
                const KL = Hpq - H;
                return { H, Hpq, KL };
            }

            function drawCharts(p_params, q_params) {
                if (pdfChartInstance) pdfChartInstance.destroy();
                if (entropyChartInstance) entropyChartInstance.destroy();

                const dataPoints = [];
                for (let x = -5; x <= 5; x += 0.1) {
                    const p_val = normalPDF(x, p_params.mu, p_params.sigma);
                    const q_val = normalPDF(x, q_params.mu, q_params.sigma);
                    dataPoints.push({ x: x.toFixed(1), p_density: p_val, q_density: q_val });
                }

                pdfChartInstance = new Chart(pdfCtx, {
                    type: 'line',
                    data: {
                        labels: dataPoints.map(d => d.x),
                        datasets: [
                            { label: 'p(x)', data: dataPoints.map(d => d.p_density), borderColor: 'rgba(60, 60, 60, 1)', borderWidth: 2 },
                            { label: 'q(x)', data: dataPoints.map(d => d.q_density), borderColor: 'rgba(150, 150, 150, 1)', borderWidth: 2, borderDash: [5, 5] },
                        ]
                    },
                    options: { responsive: true, maintainAspectRatio: false, elements: { point: { radius: 0 } }, scales: { y: { min: 0, max: 2.0 } }, plugins: { title: { display: true, text: '概率密度' } }, animation: { duration: 0 } }
                });

                entropyChartInstance = new Chart(entropyCtx, {
                    type: 'line',
                    data: {
                        labels: dataPoints.map(d => d.x),
                        datasets: [
                            { label: 'KL散度密度', data: dataPoints.map(d => d.p_density > 0 ? d.p_density * Math.log(d.p_density / d.q_density) : 0), borderColor: 'rgba(255, 159, 64, 0.8)', fill: true, backgroundColor: 'rgba(255, 159, 64, 0.2)' },
                        ]
                    },
                    options: { responsive: true, maintainAspectRatio: false, elements: { point: { radius: 0 } }, scales: { y: { min: -0.5, max: 1.5 } }, plugins: { title: { display: true, text: 'KL散度' } }, animation: { duration: 0 } }
                });
            }

            function update() {
                const p_params = { mu: parseFloat(inputs.mu_p.value), sigma: parseFloat(inputs.sigma_p.value) };
                const q_params = { mu: parseFloat(inputs.mu_q.value), sigma: parseFloat(inputs.sigma_q.value) };
                
                values.mu_p_val.textContent = p_params.mu.toFixed(1);
                values.sigma_p_val.textContent = p_params.sigma.toFixed(1);
                values.mu_q_val.textContent = q_params.mu.toFixed(1);
                values.sigma_q_val.textContent = q_params.sigma.toFixed(1);
                
                const { KL } = calcMetrics(p_params, q_params);
                drawCharts(p_params, q_params);
                
                document.getElementById('kl-result').innerHTML = `<span class="math-formula">KL散度 D<span class="math-subscript">KL</span>(q∥p): <span class="highlight">${KL.toFixed(4)}</span> nats</span>`;
            }
            
            Object.values(inputs).forEach(input => {
                if(input) input.addEventListener('input', update);
            });
            update();
        }

        function initMonteCarloDemo() {
            const canvas = document.getElementById('mc-simulationCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const canvasSize = 300;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;
            const radius = canvasSize / 2;
            
            let totalPoints = 0;
            let insidePoints = 0;
            let isRunning = false;
            let animationId;
            let speed = 50;
            
            function drawBackground() {
                ctx.clearRect(0, 0, canvasSize, canvasSize);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvasSize, canvasSize);
                ctx.strokeStyle = '#4ECDC4';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            function addPoint() {
                const x = Math.random() * canvasSize;
                const y = Math.random() * canvasSize;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const isInside = distance <= radius;
                
                ctx.fillStyle = isInside ? '#FF6B6B' : '#667eea';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();

                totalPoints++;
                if (isInside) insidePoints++;
            }
            
            function updateStats() {
                const estimatedPi = totalPoints > 0 ? (4 * insidePoints / totalPoints) : 0;
                document.getElementById('mc-totalPoints').textContent = totalPoints.toLocaleString();
                document.getElementById('mc-insidePoints').textContent = insidePoints.toLocaleString();
                document.getElementById('mc-estimatedPi').textContent = estimatedPi.toFixed(4);
            }
            
            function simulationStep() {
                if (!isRunning) return;
                const batchSize = Math.max(1, Math.floor(speed / 10));
                for (let i = 0; i < batchSize; i++) {
                    addPoint();
                }
                updateStats();
                animationId = requestAnimationFrame(simulationStep);
            }
            
            function startSimulation() {
                if (isRunning) return;
                isRunning = true;
                simulationStep();
            }
            
            function pauseSimulation() { isRunning = false; }
            
            function resetSimulation() {
                pauseSimulation();
                totalPoints = 0;
                insidePoints = 0;
                drawBackground();
                updateStats();
            }
            
            function addBatch() {
                for (let i = 0; i < 1000; i++) {
                    addPoint();
                }
                updateStats();
            }
            
            document.getElementById('mc-speedSlider')?.addEventListener('input', e => { speed = parseInt(e.target.value); });
            document.getElementById('mc-startBtn')?.addEventListener('click', startSimulation);
            document.getElementById('mc-pauseBtn')?.addEventListener('click', pauseSimulation);
            document.getElementById('mc-resetBtn')?.addEventListener('click', resetSimulation);
            document.getElementById('mc-batchBtn')?.addEventListener('click', addBatch);

            drawBackground();
            updateStats();
        }

        function initHoudiniDemo() {
            const viewport = document.getElementById('houdini-viewport');
            const radiusSlider = document.getElementById('radius-slider');
            const thicknessSlider = document.getElementById('thickness-slider');
            const radiusValue = document.getElementById('radius-value');
            const thicknessValue = document.getElementById('thickness-value');
            
            if (!viewport || !radiusSlider || !thicknessSlider) return;

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe9ecef);
            const camera = new THREE.PerspectiveCamera(75, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3.5);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            viewport.appendChild(renderer.domElement);

            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Torus
            let torusMesh;
            const material = new THREE.MeshStandardMaterial({
                color: 0x667eea,
                metalness: 0.3,
                roughness: 0.6,
            });

            function updateTorus() {
                if (torusMesh) {
                    scene.remove(torusMesh);
                    torusMesh.geometry.dispose();
                }

                const radius = parseFloat(radiusSlider.value);
                const thickness = parseFloat(thicknessSlider.value);
                radiusValue.textContent = radius.toFixed(2);
                thicknessValue.textContent = thickness.toFixed(2);

                const geometry = new THREE.TorusGeometry(radius, thickness, 24, 100);
                torusMesh = new THREE.Mesh(geometry, material);
                scene.add(torusMesh);
                controls.autoRotate = true; // Re-enable rotation after interaction
            }

            radiusSlider.addEventListener('input', updateTorus);
            thicknessSlider.addEventListener('input', updateTorus);
            
            // Stop auto-rotation on user interaction
            controls.addEventListener('start', () => { controls.autoRotate = false; });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); // for damping and auto-rotation
                renderer.render(scene, camera);
            }

            // Handle resize
            window.addEventListener('resize', () => {
                if (!viewport.offsetParent) return; // only resize if visible
                const width = viewport.clientWidth;
                const height = viewport.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }, false);

            updateTorus();
            animate();
        }

        function initAvatarGenerator(generateBtn, avatarCanvas) {
            let currentAvatarSize = 0;

             // --- UTILITIES ---
            function choice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
            function rgb(color) { return `rgb(${color[0]}, ${color[1]}, ${color[2]})`; }
            function randRange(min, max) { return Math.random() * (max - min) + min; }

            // --- FACE SHAPE DRAWERS ---
            function drawCircleFace(ctx, center, size, color) {
                const radius = size / 2;
                ctx.fillStyle = rgb(color);
                ctx.beginPath();
                ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                return { x: center.x - radius, y: center.y - radius, width: size, height: size, center: center };
            }

            function drawRoundedRectFace(ctx, center, size, color) {
                const width = size * randRange(0.9, 1.15);
                const height = size * randRange(0.9, 1.15);
                const x = center.x - width / 2;
                const y = center.y - height / 2;
                const cornerRadius = width * 0.2;
                ctx.fillStyle = rgb(color);
                ctx.beginPath();
                ctx.moveTo(x + cornerRadius, y);
                ctx.lineTo(x + width - cornerRadius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + cornerRadius);
                ctx.lineTo(x + width, y + height - cornerRadius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - cornerRadius, y + height);
                ctx.lineTo(x + cornerRadius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - cornerRadius);
                ctx.lineTo(x, y + cornerRadius);
                ctx.quadraticCurveTo(x, y, x + cornerRadius, y);
                ctx.closePath();
                ctx.fill();
                return { x, y, width, height, center };
            }

            function drawEyes(ctx, bounds) {
                const eye_y = bounds.center.y - bounds.height * randRange(0.05, 0.15);
                const eye_h_spread = bounds.width * randRange(0.14, 0.19);
                const eye_size = bounds.width * randRange(0.09, 0.14);
                const left_eye_x = bounds.center.x - eye_h_spread;
                const right_eye_x = bounds.center.x + eye_h_spread;
                const eye_color = choice(['#000080', '#006400', '#a52a2a', '#4682b4', '#6a5acd']);
                const eye_style = choice(['normal', 'smile', 'angry', 'star', 'heart']);

                const drawStar = (cx, cy, spikes, outerRadius, innerRadius) => {
                    let rot = Math.PI / 2 * 3;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - outerRadius);
                    for (let i = 0; i < spikes; i++) {
                        let x = cx + Math.cos(rot) * outerRadius;
                        let y = cy + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y);
                        rot += Math.PI / spikes;
                        x = cx + Math.cos(rot) * innerRadius;
                        y = cy + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y);
                        rot += Math.PI / spikes;
                    }
                    ctx.lineTo(cx, cy - outerRadius);
                    ctx.closePath();
                };

                const drawHeart = (x, y, width, height) => {
                    ctx.beginPath();
                    const topCurveHeight = height * 0.3;
                    ctx.moveTo(x, y + topCurveHeight);
                    ctx.bezierCurveTo(x, y, x - width / 2, y, x - width / 2, y + topCurveHeight);
                    ctx.bezierCurveTo(x - width / 2, y + (height + topCurveHeight) / 2, x, y + (height + topCurveHeight) / 2, x, y + height);
                    ctx.bezierCurveTo(x, y + (height + topCurveHeight) / 2, x + width / 2, y + (height + topCurveHeight) / 2, x + width / 2, y + topCurveHeight);
                    ctx.bezierCurveTo(x + width / 2, y, x, y, x, y + topCurveHeight);
                    ctx.closePath();
                };

                [left_eye_x, right_eye_x].forEach((eye_x, index) => {
                    switch (eye_style) {
                        case 'smile':
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = Math.max(1, eye_size / 4);
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 0.8, 1.1 * Math.PI, 1.9 * Math.PI);
                            ctx.stroke();
                            break;
                        case 'star':
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 1.1, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.fillStyle = '#FFD700';
                            drawStar(eye_x, eye_y, 5, eye_size, eye_size / 2);
                            ctx.fill();
                            break;
                        case 'heart':
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 1.1, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.fillStyle = '#E31B23';
                            drawHeart(eye_x, eye_y - eye_size*0.5, eye_size * 1.5, eye_size * 1.5);
                            ctx.fill();
                            break;
                        case 'angry':
                        case 'normal':
                        default:
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.fillStyle = eye_color;
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 0.7, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.fillStyle = 'black';
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 0.4, 0, 2 * Math.PI);
                            ctx.fill();
                            if (eye_style === 'angry') {
                                ctx.strokeStyle = 'black';
                                ctx.lineWidth = Math.max(1, eye_size/4);
                                ctx.beginPath();
                                const eyebrow_y = eye_y - eye_size * 1.2;
                                const eyebrow_x_offset = eye_size;
                                if (index === 0) {
                                    ctx.moveTo(eye_x - eyebrow_x_offset, eyebrow_y - eye_size*0.2);
                                    ctx.lineTo(eye_x + eyebrow_x_offset, eyebrow_y);
                                } else {
                                    ctx.moveTo(eye_x - eyebrow_x_offset, eyebrow_y);
                                    ctx.lineTo(eye_x + eyebrow_x_offset, eyebrow_y - eye_size*0.2);
                                }
                                ctx.stroke();
                            }
                            break;
                    }
                });
                 return { left_eye_x, right_eye_x, eye_y, eye_size };
            }
            
            function drawMouth(ctx, bounds) {
                const mouth_style = choice(['smile', 'neutral', 'surprised', 'tongue_out', 'open_smile']);
                const mouth_y = bounds.center.y + bounds.height * randRange(0.1, 0.2);
                const mouth_width = bounds.width * randRange(0.2, 0.35);
                const mouth_center_x = bounds.center.x;

                ctx.lineCap = 'round';
                ctx.strokeStyle = 'rgb(100, 50, 50)';
                ctx.fillStyle = 'rgb(100, 50, 50)';
                ctx.lineWidth = Math.max(1, bounds.width / 50 * randRange(0.8, 1.5));
                ctx.beginPath();

                switch (mouth_style) {
                    case 'smile':
                        ctx.arc(mouth_center_x, mouth_y - mouth_width * 0.1, mouth_width / 2, 0.15 * Math.PI, 0.85 * Math.PI);
                        ctx.stroke();
                        break;
                    case 'open_smile':
                         ctx.arc(mouth_center_x, mouth_y - mouth_width * 0.1, mouth_width / 2, 0.15 * Math.PI, 0.85 * Math.PI);
                         ctx.lineTo(mouth_center_x - mouth_width*0.4, mouth_y + mouth_width*0.1);
                         ctx.closePath();
                         ctx.stroke();
                         ctx.fillStyle="white";
                         ctx.fill();
                         break;
                    case 'neutral':
                        ctx.moveTo(mouth_center_x - mouth_width / 2, mouth_y);
                        ctx.lineTo(mouth_center_x + mouth_width / 2, mouth_y);
                        ctx.stroke();
                        break;
                    case 'surprised':
                         ctx.ellipse(mouth_center_x, mouth_y, mouth_width * 0.5, mouth_width * 0.6, 0, 0, 2 * Math.PI);
                         ctx.fill();
                         break;
                    case 'tongue_out':
                         ctx.arc(mouth_center_x, mouth_y, mouth_width/3, 0, Math.PI);
                         ctx.stroke();
                         ctx.fillStyle = '#ff69b4';
                         ctx.beginPath();
                         ctx.ellipse(mouth_center_x, mouth_y, mouth_width/3, mouth_width/4, 0, 0, Math.PI);
                         ctx.fill();
                         break;
                }
            }

            function generateNPCAvatar(size) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.style.borderRadius = '50%';
                canvas.style.backgroundColor = '#eef2f5';
                const ctx = canvas.getContext('2d');
                const center = { x: size / 2, y: size / 2 };

                const skin_color = choice([
                    [245, 215, 180], [210, 165, 135], [165, 120, 90], [255, 224, 189],
                    [173, 216, 230], [152, 251, 152], [230, 230, 250], [255, 182, 193]
                ]);
                const hair_color = choice([
                    [50, 30, 20], [20, 20, 20], [200, 150, 50], [150, 50, 50], [180, 180, 180], [88, 41, 0],
                    [255, 105, 180], [0, 191, 255], [50, 205, 50], [255, 165, 0], [148, 0, 211]
                ]);
                const hair_style = choice(['short', 'long', 'bald', 'mohawk']);
                const face_drawer = choice([drawCircleFace, drawRoundedRectFace]);
                const has_glasses = choice([true, false, false, false, false]);

                if (hair_style === 'long') {
                    ctx.fillStyle = rgb(hair_color);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, size * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                const face_size = size * 0.8;
                const bounds = face_drawer(ctx, center, face_size, skin_color);

                if (hair_style === 'short') {
                    ctx.fillStyle = rgb(hair_color);
                    ctx.beginPath();
                    ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height * 0.4);
                } else if (hair_style === 'mohawk') {
                    ctx.fillStyle = rgb(hair_color);
                    ctx.beginPath();
                    const mohawk_width = bounds.width * 0.3;
                    ctx.fillRect(bounds.center.x - mohawk_width / 2, bounds.y - bounds.height * 0.1, mohawk_width, bounds.height * 0.5);
                    ctx.fill();
                }

                const eye_info = drawEyes(ctx, bounds);
                drawMouth(ctx, bounds);

                if (has_glasses) {
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = Math.max(1, size/40);
                    ctx.beginPath();
                    ctx.moveTo(eye_info.left_eye_x + eye_info.eye_size, eye_info.eye_y);
                    ctx.lineTo(eye_info.right_eye_x - eye_info.eye_size, eye_info.eye_y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(eye_info.left_eye_x, eye_info.eye_y, eye_info.eye_size * 1.2, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(eye_info.right_eye_x, eye_info.eye_y, eye_info.eye_size * 1.2, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                return canvas;
            }

            const regenerateAllAvatars = () => {
                avatarCanvas.innerHTML = '';
                const style = window.getComputedStyle(avatarCanvas);
                const gap = parseFloat(style.gap) || 8;
                const padding = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
                const containerWidth = avatarCanvas.clientWidth - padding;
                const columns = 12;
                currentAvatarSize = (containerWidth - (gap * (columns - 1))) / columns;

                if (currentAvatarSize <= 0) return;

                for (let i = 0; i < 24; i++) {
                    const newAvatar = generateNPCAvatar(currentAvatarSize);
                    avatarCanvas.appendChild(newAvatar);
                }
            };

            generateBtn.addEventListener('click', () => {
                if (currentAvatarSize > 0) {
                    const newAvatar = generateNPCAvatar(currentAvatarSize);
                    avatarCanvas.appendChild(newAvatar);
                }
            });

            regenerateAllAvatars();

            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(regenerateAllAvatars, 250);
            });
        }
    </script>
</body>
</html> 