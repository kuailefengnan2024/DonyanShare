<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIæ—¶ä»£ä¿æŒè‡ªæˆ‘æ›´æ–°:æˆ‘çš„çŸ¥è¯†åº“ä¸ Cursor</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;600;700;800&display=swap');
        
        :root {
            --font-sans: 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;

            --color-text-primary: #111827;    /* Gray 900 */
            --color-text-secondary: #4b5563; /* Gray 600 */
            --color-bg-primary: #ffffff;
            --color-bg-secondary: #f9fafb;   /* Gray 50 */
            --color-border: #e5e7eb;         /* Gray 200 */
            --color-accent: #2563eb;         /* Blue 600 */
            --color-accent-light: #dbeafe;    /* Blue 100 */
            --color-success: #10b981;        /* Green 500 */
            --color-success-light: #d1fae5;   /* Green 100 */
            --color-warning: #f59e0b;        /* Amber 500 */
            --color-warning-light: #fef3c7;   /* Amber 100 */

            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: var(--font-sans);
            line-height: 1.7;
            background-color: var(--color-bg-secondary);
            color: var(--color-text-primary);
            margin: 0;
            padding: 2rem 1rem;
        }
        .wrapper {
            max-width: 1024px;
            margin: auto;
            background: var(--color-bg-primary);
            border-radius: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.05);
            border: 1px solid var(--color-border);
            overflow: hidden;
        }
        header {
            padding: 4rem 2.5rem 2rem;
            text-align: center;
            color: var(--color-text-primary);
            border-bottom: 1px solid var(--color-border);
        }
        header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin: 0 0 0.75rem 0;
            letter-spacing: -0.02em;
        }
        header p {
            font-size: 1.1rem;
            color: var(--color-text-secondary);
            max-width: 700px;
            margin: 0 auto;
        }
        .tabs {
            display: flex;
            justify-content: center;
            background-color: var(--color-bg-primary);
            padding: 0 2.5rem;
            border-bottom: 1px solid var(--color-border);
        }
        .tab-button {
            padding: 1rem 1.5rem;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 1rem;
            font-weight: 600;
            color: var(--color-text-secondary);
            position: relative;
            transition: color 0.2s ease;
            border-bottom: 3px solid transparent;
            margin-bottom: -1px; /* Overlap container border */
        }
        .tab-button.active {
            color: var(--color-accent);
            border-bottom-color: var(--color-accent);
        }
        .tab-button:hover:not(.active) {
            color: var(--color-text-primary);
        }
        .tab-button::after {
            content: none;
        }
        .tab-content {
            display: none;
            padding: 2.5rem;
        }
        .tab-content.active {
            display: block;
        }
        .card {
            background: var(--color-bg-primary);
            border: none;
            border-radius: 1rem;
            padding: 0;
            margin-bottom: 2.5rem;
        }
        .card:not(:last-child) {
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 2.5rem;
        }
        .card h3 {
            font-size: 1.5rem;
            color: var(--color-text-primary);
            margin-top: 0;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }
        .card h3 .icon {
            margin-right: 12px;
            font-size: 1.5rem;
            color: var(--color-accent);
        }
        .visualization-list {
            list-style: none;
            padding-left: 0;
            margin-top: 1.5rem;
        }
        .visualization-list li {
            margin-bottom: 1rem;
            font-size: 1rem;
            display: flex;
            align-items: center;
        }
        .visualization-list .icon {
            margin-right: 10px;
            font-size: 1.2rem;
            color: var(--color-accent);
        }
        .visualization-list a {
            text-decoration: none;
            color: var(--color-accent);
            font-weight: 500;
        }
        .visualization-list a:hover {
            text-decoration: underline;
        }
        .avatar-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
            padding: 1rem;
            background: var(--color-bg-secondary);
            border-radius: 8px;
        }
        .avatar-placeholder {
            /* Unchanged, as it's for the generator itself */
        }
        .demo-box {
            background-color: var(--color-bg-secondary);
            border: 1px solid var(--color-border);
            padding: 1.5rem;
            border-radius: 12px;
            margin-top: 1.5rem;
        }
        .demo-box .title {
            color: var(--color-text-primary);
            font-weight: 700;
            font-size: 1.1rem;
            margin: 0 0 1rem 0;
        }
        .demo-box .prompt {
            color: var(--color-text-secondary);
            font-style: normal;
            font-weight: 500;
            background: var(--color-bg-primary);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            display: block;
            border: 1px solid #d1d5db; /* Gray 300 */
            font-family: var(--font-mono);
        }
        #generate-avatar-btn {
            margin-top: 1rem; padding: 0.6rem 1.2rem; font-size: 1rem; background-color: var(--color-accent); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; transition: background-color 0.2s;
        }
        #generate-avatar-btn:hover { background-color: #1d4ed8; /* Blue 700 */ }
        
        footer {
            text-align: center;
            padding: 2rem;
            background: var(--color-bg-secondary);
            color: var(--color-text-secondary);
            font-size: 0.95rem;
        }

        /* Houdini Demo Styles */
        .vex-demo .demo-container { display: flex; gap: 1.5rem; margin-top: 1.5rem; min-height: 350px; }
        .vex-demo .viewport-container { flex: 3; background-color: var(--color-bg-secondary); border-radius: 8px; overflow: hidden; position: relative; }
        .vex-demo .controls-container { flex: 2; display: flex; flex-direction: column; gap: 1rem; }
        .vex-demo .code-block { background-color: #2d333b; color: #c9d1d9; padding: 1rem; border-radius: 6px; font-family: var(--font-mono); font-size: 0.9rem; white-space: pre-wrap; flex-grow: 1; }
        .vex-demo .code-block .comment { color: #8b949e; } .vex-demo .code-block .type { color: #ffa657; } .vex-demo .code-block .function { color: #d2a8ff; } .vex-demo .code-block .variable { color: #79c0ff; }
        .vex-demo .sliders { background: var(--color-bg-primary); padding: 1rem; border-radius: 6px; }
        .vex-demo .sliders label { display: block; margin-bottom: 0.5rem; font-weight: 500; }
        .vex-demo .sliders input[type="range"] { width: 100%; margin-bottom: 1rem; }
        @media (max-width: 768px) { .vex-demo .demo-container { flex-direction: column; } }

        /* Health Demo Styles */
        .health-container { display: flex; gap: 2rem; margin-top: 1.5rem; padding: 1.5rem; background: var(--color-bg-primary); border-radius: 12px; }
        .report-side, .advice-side { flex: 1; min-width: 0; }
        .report-side h4, .advice-side h4 { font-size: 1.2rem; font-weight: 700; margin-top: 0; margin-bottom: 1.5rem; border-bottom: 2px solid; padding-bottom: 0.5rem; }
        .report-side h4 { color: var(--color-accent); border-color: var(--color-accent-light); }
        .advice-side h4 { color: var(--color-success); border-color: var(--color-success-light); }
        .report-side h5, .advice-side h5 { font-size: 1.05rem; font-weight: 700; color: var(--color-text-primary); margin-bottom: 1rem; }
        .health-indices ul, .advice-side ul { list-style: none; padding: 0; margin: 0; }
        .health-indices li { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0.2rem; border-bottom: 1px solid var(--color-border); font-size: 0.95rem; }
        .health-indices .index-name { font-weight: 500; color: var(--color-text-secondary); }
        .health-indices .index-value { font-weight: bold; padding: 0.2rem 0.6rem; border-radius: 12px; font-size: 0.9rem; background-color: var(--color-bg-secondary); color: var(--color-text-secondary); }
        .health-indices .index-value.attention { background-color: var(--color-warning-light); color: var(--color-warning); }
        .imaging-reports { margin-top: 2rem; }
        .report-item { margin-bottom: 1.5rem; }
        .report-item h6 { font-size: 1rem; font-weight: 700; margin: 0 0 0.7rem 0; }
        .report-image-placeholder { width: 100%; height: 150px; background: var(--color-bg-secondary); border-radius: 8px; display: flex; justify-content: center; align-items: center; color: #9ca3af; font-style: italic; border: 2px dashed #d1d5db; }
        .report-text { font-size: 0.95rem; background: #fff; border: 1px solid var(--color-border); padding: 0.8rem 1rem; border-radius: 6px; line-height: 1.6; color: var(--color-text-secondary); }
        .advice-section { margin-bottom: 1.5rem; }
        .advice-side li { display: flex; align-items: flex-start; margin-bottom: 1.2rem; font-size: 0.95rem; line-height: 1.6; color: var(--color-text-secondary); }
        .advice-icon { font-size: 1.2rem; margin-right: 0.8rem; margin-top: 2px; }
        @media (max-width: 860px) { .health-container { flex-direction: column; } }

        /* --- Embedded Demo Styles --- */
        .embedded-demo { margin-top: 2rem; padding: 1.5rem; border-radius: 12px; background: var(--color-bg-secondary); border: 1px solid var(--color-border); }
        .embedded-demo h4 { font-size: 1.3rem; color: var(--color-text-primary); margin-top: 0; margin-bottom: 1.5rem; text-align: center; }
        .kl-demo .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .kl-demo .input-group { padding: 1rem; border: 1px solid var(--color-border); border-radius: 8px; }
        .kl-demo .input-group legend { font-weight: bold; color: var(--color-text-secondary); padding: 0 8px; font-size: 0.95rem; }
        .kl-demo .input-group label { display: flex; justify-content: space-between; align-items: center; margin-top: 10px; font-size: 0.9rem; }
        .kl-demo .input-group input[type="range"] { flex-grow: 1; margin: 0 10px; }
        .kl-demo .chart-container-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 320px; }
        .kl-demo .chart-container { position: relative; height: 100%; width: 100%; }
        .kl-demo .result { margin-top: 20px; font-size: 1rem; line-height: 1.7; text-align: center; background: #fff; padding: 0.8rem; border-radius: 8px;}
        .kl-demo .highlight { color: var(--color-accent); font-weight: bold; }
        .kl-demo .math-formula { font-family: 'Times New Roman', serif; font-style: italic; }
        .kl-demo .math-subscript { font-size: 0.8em; vertical-align: sub; }

        .mc-demo .simulation-area { display: flex; gap: 20px; align-items: flex-start; }
        .mc-demo .canvas-container { flex: 1; text-align: center; }
        .mc-demo canvas { border: 2px solid var(--color-border); border-radius: 8px; background: #fff; }
        .mc-demo .controls { flex: 1; }
        .mc-demo .stats { background: var(--color-text-primary); color: white; padding: 1rem; border-radius: 10px; margin-bottom: 1rem; font-size: 0.9rem; }
        .mc-demo .stat-item { display: flex; justify-content: space-between; margin-bottom: 8px; }
        .mc-demo .stat-value { font-weight: bold; color: var(--color-warning); }
        .mc-demo .controls button { background: linear-gradient(45deg, #FF6B6B, #4ECDC4); color: white; border: none; padding: 8px 16px; font-size: 0.9rem; border-radius: 20px; cursor: pointer; margin: 5px; transition: all 0.3s ease; font-weight: bold; box-shadow: var(--shadow-sm); }
        .mc-demo .controls button:hover { transform: translateY(-2px); box-shadow: var(--shadow-md); }
        .mc-demo .speed-control { margin: 1rem 0; }
        .mc-demo .speed-control label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--color-text-secondary); font-size: 0.9rem; }
        .mc-demo .speed-control input { width: 100%; }
        @media (max-width: 900px) { .kl-demo .input-grid, .kl-demo .chart-container-grid { grid-template-columns: 1fr; } .kl-demo .chart-container-grid { height: auto; } .kl-demo .chart-container { height: 250px; margin-bottom: 1rem; } }
        @media (max-width: 768px) { .mc-demo .simulation-area { flex-direction: column; } }
    </style>
</head>
<body>

    <div class="wrapper">
        <header>
            <h1>çŸ¥è¯†åº“ç¬”è®°ä¸ Cursor ğŸ’¡</h1>
            <p>æ›´æ–°è‡ªæˆ‘æ€ç»´æ¨¡å‹ï¼Œé€‚åº”AIæ—¶ä»£çš„ä¸ªäººä¹ æƒ¯</p>
        </header>

        <div class="tabs">
            <button class="tab-button active" onclick="openTab(event, 'learning')">ğŸš€ å­¦ä¹ </button>
            <button class="tab-button" onclick="openTab(event, 'work')">ğŸ’¼ å·¥ä½œ</button>
            <button class="tab-button" onclick="openTab(event, 'life')">â¤ï¸ ç”Ÿæ´»</button>
        </div>

        <div id="learning" class="tab-content active">
            <div class="card">
                <h3><span class="icon">ğŸ’¡</span>ä¸ªäººç”¨ç¬”è®°æ¥æŒç»­å­¦ä¹ çš„åŸå› </h3>
                <p><b>é AI æ—¶ä»£ï¼š</b>å†…å®¹ã€å·¥å…·å’Œç†è®ºçš„å˜åŒ–éƒ½ç›¸å¯¹ç¼“æ…¢ã€‚æˆ‘ä»¬è®°ç¬”è®°æ˜¯ä¸ºäº†â€œå½’æ¡£â€ã€‚</p>
                <p><b>AI æ—¶ä»£ï¼š</b>å†…å®¹å’Œå·¥å…·åœ¨åŠ é€Ÿè¿­ä»£ã€‚è¿™æ„å‘³ç€ï¼Œ<b>å­¦ä¹ èƒ½åŠ›æœ¬èº«ï¼Œæˆä¸ºäº†æœ€é‡è¦çš„èƒ½åŠ›ã€‚</b>æˆ‘çš„çŸ¥è¯†åº“ <code>DyVault</code> æ­£æ˜¯ä¸ºæ­¤æœåŠ¡ã€‚</p>
                <p><b>æœªæ¥è¿œæ™¯ï¼š</b>æ¯ä¸€æ¬¡è®°å½•ï¼Œéƒ½æ˜¯åœ¨ä¸ºè‡ªå·±çš„<b>â€œæ•°å­—åˆ†èº«â€</b>æä¾›å…»æ–™ã€‚éšç€æœªæ¥ AI æ¨¡å‹è®­ç»ƒé—¨æ§›çš„é™ä½ï¼Œè¿™äº›ç»“æ„åŒ–çš„æ€è€ƒå’ŒçŸ¥è¯†ï¼Œå°†æ˜¯å¤åˆ»æˆ‘ä»¬æ€ç»´æ¨¡å¼çš„å®è´µæ•°æ®ã€‚</p>
            </div>
            <div class="card">
                <h3><span class="icon">ğŸ”¬</span>å®è·µï¼šå°†æŠ½è±¡ç†è®ºâ€œå…·è±¡åŒ–â€</h3>
                <p><b>ç—›ç‚¹ï¼š</b>é¢å¯¹å¤æ‚çš„å‰æ²¿ç†è®ºï¼ˆå¦‚ AI åŸç†ã€æ•°å­¦æ¦‚å¿µï¼‰æ—¶ï¼Œå¾€å¾€éš¾ä»¥ç†è§£ã€‚</p>
                <p><b>æ–¹æ³•ï¼š</b>åˆ©ç”¨ AI çš„â€œç¿»è¯‘â€èƒ½åŠ›ï¼Œå°†å¤æ‚çš„æ¦‚å¿µç”¨æˆ‘èƒ½ç†è§£çš„æ¯”å–»å’Œæ–¹å¼é‡æ–°è§£é‡Šï¼Œå¹¶å­˜å…¥ç¬”è®°ï¼Œå¦‚ <code>Notes/DeepLearn/KL.md</code>ã€‚</p>
                
                <ul class="visualization-list">
                    <li><span class="icon">ğŸ“ˆ</span><a href="KL.html" target="_blank">KL æ•£åº¦å¯è§†åŒ– (ç‹¬ç«‹é¡µé¢)</a></li>
                    <li><span class="icon">ğŸ²</span><a href="Monte_Carlo.html" target="_blank">è’™ç‰¹å¡æ´›æ–¹æ³•æ¨¡æ‹Ÿ (ç‹¬ç«‹é¡µé¢)</a></li>
                </ul>

                <div class="embedded-demo kl-demo">
                    <h4>KL æ•£åº¦äº¤äº’æ¼”ç¤º</h4>
                    <div class="input-grid">
                        <fieldset class="input-group">
                            <legend>çœŸå®åˆ†å¸ƒ p(x)</legend>
                            <label>Î¼<sub>p</sub>: <input type="range" id="kl-mu_p" min="-2.5" max="2.5" step="0.1" value="0"><span id="kl-mu_p_val">0.0</span></label>
                            <label>Ïƒ<sub>p</sub>: <input type="range" id="kl-sigma_p" min="0.2" max="2" step="0.1" value="1"><span id="kl-sigma_p_val">1.0</span></label>
                        </fieldset>
                        <fieldset class="input-group">
                            <legend>è¿‘ä¼¼åˆ†å¸ƒ q(x)</legend>
                            <label>Î¼<sub>q</sub>: <input type="range" id="kl-mu_q" min="-2.5" max="2.5" step="0.1" value="0.5"><span id="kl-mu_q_val">0.5</span></label>
                            <label>Ïƒ<sub>q</sub>: <input type="range" id="kl-sigma_q" min="0.2" max="2" step="0.1" value="1.2"><span id="kl-sigma_q_val">1.2</span></label>
                        </fieldset>
                    </div>
                    <div class="chart-container-grid">
                        <div class="chart-container"><canvas id="kl-pdfChart"></canvas></div>
                        <div class="chart-container"><canvas id="kl-entropyChart"></canvas></div>
                    </div>
                    <div class="result" id="kl-result"></div>
                </div>

                <div class="embedded-demo mc-demo">
                    <h4>è’™ç‰¹å¡æ´›ä¼°ç®— Ï€</h4>
                    <div class="simulation-area">
                        <div class="canvas-container">
                            <canvas id="mc-simulationCanvas" width="300" height="300"></canvas>
                        </div>
                        <div class="controls">
                            <div class="stats">
                                <div class="stat-item"><span>æ€»ç‚¹æ•°:</span><span class="stat-value" id="mc-totalPoints">0</span></div>
                                <div class="stat-item"><span>åœ†å†…ç‚¹æ•°:</span><span class="stat-value" id="mc-insidePoints">0</span></div>
                                <div class="stat-item"><span>ä¼°ç®— Ï€ å€¼:</span><span class="stat-value" id="mc-estimatedPi">0.0000</span></div>
                            </div>
                            <div class="speed-control">
                                <label>æ¨¡æ‹Ÿé€Ÿåº¦:</label>
                                <input type="range" id="mc-speedSlider" min="1" max="100" value="50">
                            </div>
                            <button id="mc-startBtn">ğŸš€ å¼€å§‹</button>
                            <button id="mc-pauseBtn">â¸ï¸ æš‚åœ</button>
                            <button id="mc-resetBtn">ğŸ”„ é‡ç½®</button>
                            <button id="mc-batchBtn">â• æ‰¹é‡(1k)</button>
                        </div>
                    </div>
                </div>

                <div class="demo-box">
                    <div class="title">ğŸ¬ ç°åœºæŒ‘æˆ˜: åŒ–ç¹ä¸ºç®€</div>
                    <p><strong>åœºæ™¯:</strong> æˆ‘æƒ³è®©è®¾è®¡å¸ˆåŒäº‹ä¹Ÿèƒ½ç§’æ‡‚â€œKLæ•£åº¦â€ã€‚</p>
                    <p class="prompt">@file:Notes/DeepLearn/KL.md æˆ‘æ˜¯ä¸€ä¸ªè®¾è®¡å¸ˆï¼Œè¯·ç”¨ä¸€ä¸ªå…³äºâ€œä¸¤å¼ è®¾è®¡ç¨¿å·®å¼‚â€çš„æ¯”å–»ï¼Œå‘æˆ‘è§£é‡Šè¿™ä¸ªæ–‡æ¡£é‡Œæåˆ°çš„â€œKLæ•£åº¦â€æ˜¯ä»€ä¹ˆã€‚</p>
                </div>
            </div>
        </div>

        <div id="work" class="tab-content">
            <div class="card">
                <h3><span class="icon">ğŸ› ï¸</span>å®è·µï¼šæé€ŸæŒæ¡å·¥ä½œæ–°æŠ€èƒ½</h3>
                <p><b>ç—›ç‚¹ï¼š</b>å·¥ä½œä¸­éœ€è¦å¿«é€Ÿä¸Šæ‰‹ä¸€ä¸ªæ–°è½¯ä»¶ï¼Œæ¯”å¦‚ Houdiniï¼Œä½†å®˜æ–¹æ–‡æ¡£å¤ªåºå¤§ã€‚</p>
                <p><b>æ–¹æ³•ï¼š</b>è®© Cursor æˆä¸ºæˆ‘çš„â€œç§äººæ•™å¸ˆâ€ï¼Œç›´æ¥é’ˆå¯¹æˆ‘çš„é—®é¢˜ç»™å‡ºç­”æ¡ˆï¼Œå¹¶å°†æœ€æœ‰ä»·å€¼çš„ä¿¡æ¯æ²‰æ·€åˆ°ç¬”è®°ä¸­ã€‚ä¾‹å¦‚ï¼Œè¿™æ˜¯æˆ‘çš„ <a href="Vex.html" target="_blank">Vex è„šæœ¬å­¦ä¹ ç¬”è®°</a>ã€‚</p>
                
                <div class="demo-box vex-demo" style="margin-top: 2rem;">
                    <div class="title">ğŸ¬ VEX äº¤äº’æ¼”ç¤ºï¼šç¨‹åºåŒ–åœ†ç¯</div>
                    <div class="demo-container">
                        <div class="viewport-container" id="houdini-viewport"></div>
                        <div class="controls-container">
                            <div class="code-block">
<pre><code><span class="comment">// VEX code to generate a torus</span>
<span class="comment">// Parameters are controlled by sliders</span>

<span class="type">float</span> <span class="variable">radius</span>    = <span class="function">chf</span>(<span class="string">"radius"</span>);
<span class="type">float</span> <span class="variable">thickness</span> = <span class="function">chf</span>(<span class="string">"thickness"</span>);

<span class="comment">// (Pseudo-code for concept)</span>
<span class="function">addprim</span>(<span class="variable">@OpInput1</span>, <span class="string">"torus"</span>, {
  <span class="string">"radius"</span>: <span class="variable">radius</span>,
  <span class="string">"tube"</span>: <span class="variable">thickness</span>
});</code></pre>
                            </div>
                            <div class="sliders">
                                <label for="radius-slider">åœ†ç¯åŠå¾„ (Radius): <span id="radius-value">1.0</span></label>
                                <input type="range" id="radius-slider" min="0.5" max="2" step="0.05" value="1.0">
                                
                                <label for="thickness-slider">ç®¡é“ç²—ç»† (Thickness): <span id="thickness-value">0.4</span></label>
                                <input type="range" id="thickness-slider" min="0.1" max="1" step="0.05" value="0.4">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="demo-box" style="margin-top: 2rem;">
                    <div class="title">ğŸ¬ ç°åœºæŒ‘æˆ˜: â€œçƒ¹é¥ªâ€Houdini</div>
                    <p><strong>åœºæ™¯:</strong> æˆ‘æƒ³å¿«é€Ÿç†è§£ Houdini ä¸åŒå·¥ä½œæ¨¡å—çš„æ ¸å¿ƒåŒºåˆ«ã€‚</p>
                    <p class="prompt">æˆ‘æ˜¯ä¸€ä¸ª Houdini åˆå­¦è€…ï¼Œè¯·ç”¨ä¸€ä¸ªå…³äºâ€œåšé¥­â€çš„æ¯”å–»ï¼Œè§£é‡Šä¸€ä¸‹ â€œSOPsâ€, â€œVOPsâ€, â€œDOPsâ€ è¿™ä¸‰ä¸ªæ¦‚å¿µçš„æ ¸å¿ƒåŒºåˆ«æ˜¯ä»€ä¹ˆï¼Ÿ</p>
                </div>
            </div>
            <div class="card">
                <h3><span class="icon">ğŸ”„</span>æ ¹æ®ç¬”è®°å†…å®¹ç”Ÿæˆç¬¦åˆéœ€æ±‚çš„ä»»æ„è„šæœ¬</h3>
                <p><b>ä¼˜åŠ¿ï¼š</b>è¿™æ˜¯é£ä¹¦ç­‰çº¯æ–‡æ¡£å·¥å…·æ— æ³•æ¯”æ‹Ÿçš„ã€‚æˆ‘å¯ä»¥åœ¨ç¬”è®°é‡Œæ„æ€ï¼Œç„¶åç«‹åˆ»è®© Cursor å¸®æˆ‘åˆ›å»ºé¡¹ç›® Demo æ¥éªŒè¯æƒ³æ³•ã€‚</p>
                <div class="demo-box">
                    <div class="title">ğŸ¬ ç°åœºæŒ‘æˆ˜: AI é©±åŠ¨çš„å¤´åƒç”Ÿæˆå™¨</div>
                    <p><strong>åœºæ™¯:</strong> æˆ‘æƒ³ç”¨ Python è„šæœ¬å¿«é€Ÿç”Ÿæˆä¸€ç³»åˆ—é£æ ¼åŒ–çš„æ¸¸æˆå¤´åƒã€‚</p>
                    <p class="prompt">@file:Avatar.py è¯·è§£é‡Šè¿™ä¸ªè„šæœ¬çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œå¹¶è¯´æ˜å¦‚ä½•ä½¿ç”¨å®ƒæ¥ç”Ÿæˆå¤´åƒã€‚</p>
                    <button id="generate-avatar-btn" style="margin-top: 1rem; padding: 0.6rem 1.2rem; font-size: 1rem; background-color: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer;">ç‚¹å‡»ç”Ÿæˆå¤´åƒ</button>
                </div>
                <div class="avatar-preview" id="avatar-canvas">
                    <!-- Avatars will be generated here -->
                </div>
            </div>
            <div class="card">
                <h3><span class="icon">ğŸ“Š</span>æ ¹æ®é¡¹ç›®ä»£ç å¿«é€Ÿç”Ÿæˆäº¤äº’demoæ–¹ä¾¿æ±‡æŠ¥</h3>
                <p>è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨ AI è¾…åŠ©ç”Ÿæˆçš„äº¤äº’å¼äº§å“åŸå‹ï¼Œå±•ç¤ºäº†â€œAIåˆ›æ„æ€»ç›‘â€çš„æ ¸å¿ƒå·¥ä½œæµç¨‹ã€‚æ‚¨å¯ä»¥ <a href="prototype_ui.html" target="_blank">ç‚¹å‡»æ­¤å¤„æŸ¥çœ‹åŸå‹</a>ã€‚</p>
            </div>
        </div>

        <div id="life" class="tab-content">
            <div class="card">
                <h3><span class="icon">â¤ï¸â€ğŸ©¹</span>å®è·µï¼šå°†æ•°æ®è½¬åŒ–ä¸ºç”Ÿæ´»æ´è§</h3>
                <p><b>æ–¹æ³•ï¼š</b>å°†ä½“æ£€æŠ¥å‘Šç­‰å…³é”®å¥åº·ä¿¡æ¯å­˜å…¥ç¬”è®°ï¼Œç„¶åè®© AI æˆä¸ºæˆ‘çš„â€œå¥åº·ç®¡å®¶â€ï¼Œå¸®æˆ‘åˆ†æå¹¶åˆ¶å®šå¯æ‰§è¡Œçš„è®¡åˆ’ã€‚</p>
                
                <div class="health-container">
                    <!-- Left Side: The Report -->
                    <div class="report-side">
                        <h4>ğŸ“˜ æˆ‘çš„å¥åº·ç¬”è®°</h4>
                        <div class="health-indices">
                            <h5>å…³é”®æŒ‡æ ‡ä¸çŠ¶æ€</h5>
                            <ul>
                                <li><span class="index-name">ä½å¯†åº¦è„‚è›‹ç™½(LDL)</span><span class="index-value attention">åé«˜</span></li>
                                <li><span class="index-name">ä½“é‡æŒ‡æ•°(BMI)</span><span class="index-value attention">25.8</span></li>
                                <li><span class="index-name">ç¡çœ è´¨é‡</span><span class="index-value">æœ‰å¾…æ”¹å–„</span></li>
                            </ul>
                        </div>
                        <div class="imaging-reports">
                            <h5>ä¸“é¡¹æ£€æŸ¥è®°å½•</h5>
                            <div class="report-item">
                                <h6>èƒ¸éƒ¨æ£€æŸ¥</h6>
                                <div class="report-image-placeholder">
                                    <span>èƒ¸éƒ¨å½±åƒ (ç¤ºæ„)</span>
                                </div>
                            </div>
                             <div class="report-item">
                                <h6>èƒƒéƒ¨æ£€æŸ¥</h6>
                                <p class="report-text"><strong>ç»“è®ºï¼š</strong>æ…¢æ€§éèç¼©æ€§èƒƒç‚ã€‚å»ºè®®æ¸…æ·¡é¥®é£Ÿï¼Œè§„å¾‹ä½œæ¯ã€‚</p>
                            </div>
                        </div>
                    </div>

                    <!-- Right Side: The AI Advice -->
                    <div class="advice-side">
                        <h4>ğŸ’¡ AI ç”Ÿæ´»å°åŠ©æ‰‹</h4>
                        <div class="advice-section">
                            <h5>ç»¼åˆå»ºè®®</h5>
                            <ul>
                                <li><span class="advice-icon">ğŸ¥—</span>æ³¨æ„åˆ°æ‚¨çš„å‡ é¡¹æŒ‡æ ‡éœ€è¦å…³æ³¨ï¼Œå¯ä»¥ä»å¢åŠ è†³é£Ÿçº¤ç»´å¼€å§‹ï¼Œæ¯”å¦‚å¤šåƒè”¬èœã€ç”¨ç‡•éº¦ä»£æ›¿éƒ¨åˆ†ä¸»é£Ÿã€‚</li>
                                <li><span class="advice-icon">ğŸ‘Ÿ</span>æé«˜BMIå’ŒLDLçš„â€œæ€§ä»·æ¯”â€ä¹‹ç‹æ˜¯å¿«èµ°ï¼æ¯å¤©30åˆ†é’Ÿï¼Œå¯¹æ”¹å–„æŒ‡æ ‡å’ŒèƒƒåŠ¨åŠ›éƒ½æœ‰å¥½å¤„ã€‚</li>
                                <li><span class="advice-icon">ï¿½ï¿½</span>å¥½çš„ç¡çœ æ˜¯å¥åº·åŸºçŸ³ã€‚ç¡å‰å†¥æƒ³5åˆ†é’Ÿæˆ–å¬å¬è½»éŸ³ä¹ï¼Œèƒ½æœ‰æ•ˆæå‡ç¡çœ è´¨é‡ã€‚</li>
                                 <li><span class="advice-icon">ğŸš­</span>èƒ¸éƒ¨æ£€æŸ¥æ²¡å‘ç°å¤§é—®é¢˜ï¼Œä½†ä¹Ÿè¦ä¿æŒè­¦æƒ•ï¼Œè¿œç¦»çƒŸè‰ç¯å¢ƒå¯¹è‚ºéƒ¨å¥åº·æœ€é‡è¦ã€‚</li>
                            </ul>
                        </div>
                    </div>
                </div>

                 <div class="demo-box" style="margin-top: 2rem;">
                    <div class="title">ğŸ¬ ç°åœºæŒ‘æˆ˜: æˆ‘çš„ AI å¥åº·ç®¡å®¶</div>
                    <p><strong>åœºæ™¯:</strong> æˆ‘æƒ³æ ¹æ®ä½“æ£€æŠ¥å‘Šï¼Œåˆ¶å®šä¸€ä¸ªç®€å•çš„å¥åº·è®¡åˆ’ã€‚</p>
                    <p class="prompt">@file:Health/250416.md åŸºäºè¿™ä»½æ–‡æ¡£ä¸­æåˆ°çš„â€˜ä½å¯†åº¦è„‚è›‹ç™½åé«˜â€™ï¼Œå¸®æˆ‘ç”¨ markdown æ ¼å¼åˆ¶å®šä¸€ä¸ªä¸ºæœŸä¸€å‘¨çš„ã€æ³¨é‡å¥åº·é¥®é£Ÿå’Œæœ‰æ°§è¿åŠ¨çš„ç®€å•è®¡åˆ’è¡¨ã€‚</p>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>é€‰æ‹©ä¸€ä¸ªå¥½çš„å·¥å…·ï¼Œæœ¬è´¨ä¸Šæ˜¯é€‰æ‹©ä¸€ç§èƒ½æ”¾å¤§æˆ‘ä»¬å­¦ä¹ èƒ½åŠ›çš„æ€ç»´æ–¹å¼ã€‚<br>Cursor + ä¸ªäººçŸ¥è¯†åº“ï¼Œå°±æ˜¯æˆ‘ç°é˜¶æ®µæ‰¾åˆ°çš„æœ€ä½³ç­”æ¡ˆã€‚</p>
    </footer>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        // This function needs to be global for the onclick="" attribute to work
        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }
    
        document.addEventListener('DOMContentLoaded', () => {
            // --- DEMO INITIALIZATION ---
            const learningTab = document.getElementById('learning');
            const workTab = document.getElementById('work');

            // --- Learning Tab ---
            if (learningTab && learningTab.classList.contains('active')) {
                initLearningTabDemos();
            }

            // --- Work Tab ---
            const initWorkTabDemos = () => {
                // Avatar Demo
                const avatarCanvas = document.getElementById('avatar-canvas');
                if (avatarCanvas && avatarCanvas.offsetParent !== null && !avatarCanvas.dataset.initialized) {
                    avatarCanvas.dataset.initialized = 'true';
                    const generateBtn = document.getElementById('generate-avatar-btn');
                    initAvatarGenerator(generateBtn, avatarCanvas);
                }

                // Houdini Demo
                const houdiniViewport = document.getElementById('houdini-viewport');
                if (houdiniViewport && houdiniViewport.offsetParent !== null && !houdiniViewport.dataset.initialized) {
                    houdiniViewport.dataset.initialized = 'true';
                    initHoudiniDemo();
                }
            };
            
            // Use a single observer for the "Work" tab to initialize all demos within it.
            const workTabObserver = new MutationObserver(() => {
                // When the tab's style changes (e.g., display: block), check to initialize demos.
                initWorkTabDemos();
            });

            if (workTab) {
                workTabObserver.observe(workTab, { attributes: true, attributeFilter: ['style'] });
            }
             // Fallback for cases where the tab is already visible on load
            if (workTab && workTab.classList.contains('active')) {
                // This case is less likely for the work tab unless it's set as default
                initWorkTabDemos();
            }
        });

        function initLearningTabDemos() {
            // Check if already initialized to prevent re-running on tab clicks
            if (document.body.dataset.learningDemosInitialized) return;
            document.body.dataset.learningDemosInitialized = 'true';

            initKLDemo();
            initMonteCarloDemo();
        }

        function initKLDemo() {
            let pdfChartInstance = null;
            let entropyChartInstance = null;
            const inputs = {
                mu_p: document.getElementById('kl-mu_p'), sigma_p: document.getElementById('kl-sigma_p'),
                mu_q: document.getElementById('kl-mu_q'), sigma_q: document.getElementById('kl-sigma_q'),
            };
            const values = {
                mu_p_val: document.getElementById('kl-mu_p_val'), sigma_p_val: document.getElementById('kl-sigma_p_val'),
                mu_q_val: document.getElementById('kl-mu_q_val'), sigma_q_val: document.getElementById('kl-sigma_q_val'),
            };
            const pdfCtx = document.getElementById('kl-pdfChart')?.getContext('2d');
            const entropyCtx = document.getElementById('kl-entropyChart')?.getContext('2d');
            
            if (!pdfCtx || !entropyCtx) return;

            const safeLog = (x) => (x > 0 ? Math.log(x) : -Infinity);
            const entropyDensity = (p, base_p) => (p > 0 ? -p * safeLog(base_p) : 0);

            function normalPDF(x, mu, sigma) {
                return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2));
            }

            function calcMetrics(p, q) {
                const H = 0.5 * Math.log(2 * Math.PI * Math.E * p.sigma * p.sigma);
                const Hpq = 0.5 * Math.log(2 * Math.PI * q.sigma * q.sigma) + (p.sigma * p.sigma + Math.pow(p.mu - q.mu, 2)) / (2 * q.sigma * q.sigma);
                const KL = Hpq - H;
                return { H, Hpq, KL };
            }

            function drawCharts(p_params, q_params) {
                if (pdfChartInstance) pdfChartInstance.destroy();
                if (entropyChartInstance) entropyChartInstance.destroy();

                const dataPoints = [];
                for (let x = -5; x <= 5; x += 0.1) {
                    const p_val = normalPDF(x, p_params.mu, p_params.sigma);
                    const q_val = normalPDF(x, q_params.mu, q_params.sigma);
                    dataPoints.push({ x: x.toFixed(1), p_density: p_val, q_density: q_val });
                }

                pdfChartInstance = new Chart(pdfCtx, {
                    type: 'line',
                    data: {
                        labels: dataPoints.map(d => d.x),
                        datasets: [
                            { label: 'p(x)', data: dataPoints.map(d => d.p_density), borderColor: 'rgba(60, 60, 60, 1)', borderWidth: 2 },
                            { label: 'q(x)', data: dataPoints.map(d => d.q_density), borderColor: 'rgba(150, 150, 150, 1)', borderWidth: 2, borderDash: [5, 5] },
                        ]
                    },
                    options: { responsive: true, maintainAspectRatio: false, elements: { point: { radius: 0 } }, scales: { y: { min: 0, max: 2.0 } }, plugins: { title: { display: true, text: 'æ¦‚ç‡å¯†åº¦' } }, animation: { duration: 0 } }
                });

                entropyChartInstance = new Chart(entropyCtx, {
                    type: 'line',
                    data: {
                        labels: dataPoints.map(d => d.x),
                        datasets: [
                            { label: 'KLæ•£åº¦å¯†åº¦', data: dataPoints.map(d => d.p_density > 0 ? d.p_density * Math.log(d.p_density / d.q_density) : 0), borderColor: 'rgba(255, 159, 64, 0.8)', fill: true, backgroundColor: 'rgba(255, 159, 64, 0.2)' },
                        ]
                    },
                    options: { responsive: true, maintainAspectRatio: false, elements: { point: { radius: 0 } }, scales: { y: { min: -0.5, max: 1.5 } }, plugins: { title: { display: true, text: 'KLæ•£åº¦' } }, animation: { duration: 0 } }
                });
            }

            function update() {
                const p_params = { mu: parseFloat(inputs.mu_p.value), sigma: parseFloat(inputs.sigma_p.value) };
                const q_params = { mu: parseFloat(inputs.mu_q.value), sigma: parseFloat(inputs.sigma_q.value) };
                
                values.mu_p_val.textContent = p_params.mu.toFixed(1);
                values.sigma_p_val.textContent = p_params.sigma.toFixed(1);
                values.mu_q_val.textContent = q_params.mu.toFixed(1);
                values.sigma_q_val.textContent = q_params.sigma.toFixed(1);
                
                const { KL } = calcMetrics(p_params, q_params);
                drawCharts(p_params, q_params);
                
                document.getElementById('kl-result').innerHTML = `<span class="math-formula">KLæ•£åº¦ D<span class="math-subscript">KL</span>(qâˆ¥p): <span class="highlight">${KL.toFixed(4)}</span> nats</span>`;
            }
            
            Object.values(inputs).forEach(input => {
                if(input) input.addEventListener('input', update);
            });
            update();
        }

        function initMonteCarloDemo() {
            const canvas = document.getElementById('mc-simulationCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const canvasSize = 300;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const centerX = canvasSize / 2;
            const centerY = canvasSize / 2;
            const radius = canvasSize / 2;
            
            let totalPoints = 0;
            let insidePoints = 0;
            let isRunning = false;
            let animationId;
            let speed = 50;
            
            function drawBackground() {
                ctx.clearRect(0, 0, canvasSize, canvasSize);
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvasSize, canvasSize);
                ctx.strokeStyle = '#4ECDC4';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            function addPoint() {
                const x = Math.random() * canvasSize;
                const y = Math.random() * canvasSize;
                const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                const isInside = distance <= radius;
                
                ctx.fillStyle = isInside ? '#FF6B6B' : '#667eea';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();

                totalPoints++;
                if (isInside) insidePoints++;
            }
            
            function updateStats() {
                const estimatedPi = totalPoints > 0 ? (4 * insidePoints / totalPoints) : 0;
                document.getElementById('mc-totalPoints').textContent = totalPoints.toLocaleString();
                document.getElementById('mc-insidePoints').textContent = insidePoints.toLocaleString();
                document.getElementById('mc-estimatedPi').textContent = estimatedPi.toFixed(4);
            }
            
            function simulationStep() {
                if (!isRunning) return;
                const batchSize = Math.max(1, Math.floor(speed / 10));
                for (let i = 0; i < batchSize; i++) {
                    addPoint();
                }
                updateStats();
                animationId = requestAnimationFrame(simulationStep);
            }
            
            function startSimulation() {
                if (isRunning) return;
                isRunning = true;
                simulationStep();
            }
            
            function pauseSimulation() { isRunning = false; }
            
            function resetSimulation() {
                pauseSimulation();
                totalPoints = 0;
                insidePoints = 0;
                drawBackground();
                updateStats();
            }
            
            function addBatch() {
                for (let i = 0; i < 1000; i++) {
                    addPoint();
                }
                updateStats();
            }
            
            document.getElementById('mc-speedSlider')?.addEventListener('input', e => { speed = parseInt(e.target.value); });
            document.getElementById('mc-startBtn')?.addEventListener('click', startSimulation);
            document.getElementById('mc-pauseBtn')?.addEventListener('click', pauseSimulation);
            document.getElementById('mc-resetBtn')?.addEventListener('click', resetSimulation);
            document.getElementById('mc-batchBtn')?.addEventListener('click', addBatch);

            drawBackground();
            updateStats();
        }

        function initHoudiniDemo() {
            const viewport = document.getElementById('houdini-viewport');
            const radiusSlider = document.getElementById('radius-slider');
            const thicknessSlider = document.getElementById('thickness-slider');
            const radiusValue = document.getElementById('radius-value');
            const thicknessValue = document.getElementById('thickness-value');
            
            if (!viewport || !radiusSlider || !thicknessSlider) return;

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe9ecef);
            const camera = new THREE.PerspectiveCamera(75, viewport.clientWidth / viewport.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 3.5);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(viewport.clientWidth, viewport.clientHeight);
            viewport.appendChild(renderer.domElement);

            // Controls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.8;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // Torus
            let torusMesh;
            const material = new THREE.MeshStandardMaterial({
                color: 0x667eea,
                metalness: 0.3,
                roughness: 0.6,
            });

            function updateTorus() {
                if (torusMesh) {
                    scene.remove(torusMesh);
                    torusMesh.geometry.dispose();
                }

                const radius = parseFloat(radiusSlider.value);
                const thickness = parseFloat(thicknessSlider.value);
                radiusValue.textContent = radius.toFixed(2);
                thicknessValue.textContent = thickness.toFixed(2);

                const geometry = new THREE.TorusGeometry(radius, thickness, 24, 100);
                torusMesh = new THREE.Mesh(geometry, material);
                scene.add(torusMesh);
                controls.autoRotate = true; // Re-enable rotation after interaction
            }

            radiusSlider.addEventListener('input', updateTorus);
            thicknessSlider.addEventListener('input', updateTorus);
            
            // Stop auto-rotation on user interaction
            controls.addEventListener('start', () => { controls.autoRotate = false; });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); // for damping and auto-rotation
                renderer.render(scene, camera);
            }

            // Handle resize
            window.addEventListener('resize', () => {
                if (!viewport.offsetParent) return; // only resize if visible
                const width = viewport.clientWidth;
                const height = viewport.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }, false);

            updateTorus();
            animate();
        }

        function initAvatarGenerator(generateBtn, avatarCanvas) {
            let currentAvatarSize = 0;

             // --- UTILITIES ---
            function choice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
            function rgb(color) { return `rgb(${color[0]}, ${color[1]}, ${color[2]})`; }
            function randRange(min, max) { return Math.random() * (max - min) + min; }

            // --- FACE SHAPE DRAWERS ---
            function drawCircleFace(ctx, center, size, color) {
                const radius = size / 2;
                ctx.fillStyle = rgb(color);
                ctx.beginPath();
                ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                return { x: center.x - radius, y: center.y - radius, width: size, height: size, center: center };
            }

            function drawRoundedRectFace(ctx, center, size, color) {
                const width = size * randRange(0.9, 1.15);
                const height = size * randRange(0.9, 1.15);
                const x = center.x - width / 2;
                const y = center.y - height / 2;
                const cornerRadius = width * 0.2;
                ctx.fillStyle = rgb(color);
                ctx.beginPath();
                ctx.moveTo(x + cornerRadius, y);
                ctx.lineTo(x + width - cornerRadius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + cornerRadius);
                ctx.lineTo(x + width, y + height - cornerRadius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - cornerRadius, y + height);
                ctx.lineTo(x + cornerRadius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - cornerRadius);
                ctx.lineTo(x, y + cornerRadius);
                ctx.quadraticCurveTo(x, y, x + cornerRadius, y);
                ctx.closePath();
                ctx.fill();
                return { x, y, width, height, center };
            }

            function drawEyes(ctx, bounds) {
                const eye_y = bounds.center.y - bounds.height * randRange(0.05, 0.15);
                const eye_h_spread = bounds.width * randRange(0.14, 0.19);
                const eye_size = bounds.width * randRange(0.09, 0.14);
                const left_eye_x = bounds.center.x - eye_h_spread;
                const right_eye_x = bounds.center.x + eye_h_spread;
                const eye_color = choice(['#000080', '#006400', '#a52a2a', '#4682b4', '#6a5acd']);
                const eye_style = choice(['normal', 'smile', 'angry', 'star', 'heart']);

                const drawStar = (cx, cy, spikes, outerRadius, innerRadius) => {
                    let rot = Math.PI / 2 * 3;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - outerRadius);
                    for (let i = 0; i < spikes; i++) {
                        let x = cx + Math.cos(rot) * outerRadius;
                        let y = cy + Math.sin(rot) * outerRadius;
                        ctx.lineTo(x, y);
                        rot += Math.PI / spikes;
                        x = cx + Math.cos(rot) * innerRadius;
                        y = cy + Math.sin(rot) * innerRadius;
                        ctx.lineTo(x, y);
                        rot += Math.PI / spikes;
                    }
                    ctx.lineTo(cx, cy - outerRadius);
                    ctx.closePath();
                };

                const drawHeart = (x, y, width, height) => {
                    ctx.beginPath();
                    const topCurveHeight = height * 0.3;
                    ctx.moveTo(x, y + topCurveHeight);
                    ctx.bezierCurveTo(x, y, x - width / 2, y, x - width / 2, y + topCurveHeight);
                    ctx.bezierCurveTo(x - width / 2, y + (height + topCurveHeight) / 2, x, y + (height + topCurveHeight) / 2, x, y + height);
                    ctx.bezierCurveTo(x, y + (height + topCurveHeight) / 2, x + width / 2, y + (height + topCurveHeight) / 2, x + width / 2, y + topCurveHeight);
                    ctx.bezierCurveTo(x + width / 2, y, x, y, x, y + topCurveHeight);
                    ctx.closePath();
                };

                [left_eye_x, right_eye_x].forEach((eye_x, index) => {
                    switch (eye_style) {
                        case 'smile':
                            ctx.strokeStyle = 'black';
                            ctx.lineWidth = Math.max(1, eye_size / 4);
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 0.8, 1.1 * Math.PI, 1.9 * Math.PI);
                            ctx.stroke();
                            break;
                        case 'star':
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 1.1, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.fillStyle = '#FFD700';
                            drawStar(eye_x, eye_y, 5, eye_size, eye_size / 2);
                            ctx.fill();
                            break;
                        case 'heart':
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 1.1, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.fillStyle = '#E31B23';
                            drawHeart(eye_x, eye_y - eye_size*0.5, eye_size * 1.5, eye_size * 1.5);
                            ctx.fill();
                            break;
                        case 'angry':
                        case 'normal':
                        default:
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.fillStyle = eye_color;
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 0.7, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.fillStyle = 'black';
                            ctx.beginPath();
                            ctx.arc(eye_x, eye_y, eye_size * 0.4, 0, 2 * Math.PI);
                            ctx.fill();
                            if (eye_style === 'angry') {
                                ctx.strokeStyle = 'black';
                                ctx.lineWidth = Math.max(1, eye_size/4);
                                ctx.beginPath();
                                const eyebrow_y = eye_y - eye_size * 1.2;
                                const eyebrow_x_offset = eye_size;
                                if (index === 0) {
                                    ctx.moveTo(eye_x - eyebrow_x_offset, eyebrow_y - eye_size*0.2);
                                    ctx.lineTo(eye_x + eyebrow_x_offset, eyebrow_y);
                                } else {
                                    ctx.moveTo(eye_x - eyebrow_x_offset, eyebrow_y);
                                    ctx.lineTo(eye_x + eyebrow_x_offset, eyebrow_y - eye_size*0.2);
                                }
                                ctx.stroke();
                            }
                            break;
                    }
                });
                 return { left_eye_x, right_eye_x, eye_y, eye_size };
            }
            
            function drawMouth(ctx, bounds) {
                const mouth_style = choice(['smile', 'neutral', 'surprised', 'tongue_out', 'open_smile']);
                const mouth_y = bounds.center.y + bounds.height * randRange(0.1, 0.2);
                const mouth_width = bounds.width * randRange(0.2, 0.35);
                const mouth_center_x = bounds.center.x;

                ctx.lineCap = 'round';
                ctx.strokeStyle = 'rgb(100, 50, 50)';
                ctx.fillStyle = 'rgb(100, 50, 50)';
                ctx.lineWidth = Math.max(1, bounds.width / 50 * randRange(0.8, 1.5));
                ctx.beginPath();

                switch (mouth_style) {
                    case 'smile':
                        ctx.arc(mouth_center_x, mouth_y - mouth_width * 0.1, mouth_width / 2, 0.15 * Math.PI, 0.85 * Math.PI);
                        ctx.stroke();
                        break;
                    case 'open_smile':
                         ctx.arc(mouth_center_x, mouth_y - mouth_width * 0.1, mouth_width / 2, 0.15 * Math.PI, 0.85 * Math.PI);
                         ctx.lineTo(mouth_center_x - mouth_width*0.4, mouth_y + mouth_width*0.1);
                         ctx.closePath();
                         ctx.stroke();
                         ctx.fillStyle="white";
                         ctx.fill();
                         break;
                    case 'neutral':
                        ctx.moveTo(mouth_center_x - mouth_width / 2, mouth_y);
                        ctx.lineTo(mouth_center_x + mouth_width / 2, mouth_y);
                        ctx.stroke();
                        break;
                    case 'surprised':
                         ctx.ellipse(mouth_center_x, mouth_y, mouth_width * 0.5, mouth_width * 0.6, 0, 0, 2 * Math.PI);
                         ctx.fill();
                         break;
                    case 'tongue_out':
                         ctx.arc(mouth_center_x, mouth_y, mouth_width/3, 0, Math.PI);
                         ctx.stroke();
                         ctx.fillStyle = '#ff69b4';
                         ctx.beginPath();
                         ctx.ellipse(mouth_center_x, mouth_y, mouth_width/3, mouth_width/4, 0, 0, Math.PI);
                         ctx.fill();
                         break;
                }
            }

            function generateNPCAvatar(size) {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                canvas.style.borderRadius = '50%';
                canvas.style.backgroundColor = '#eef2f5';
                const ctx = canvas.getContext('2d');
                const center = { x: size / 2, y: size / 2 };

                const skin_color = choice([
                    [245, 215, 180], [210, 165, 135], [165, 120, 90], [255, 224, 189],
                    [173, 216, 230], [152, 251, 152], [230, 230, 250], [255, 182, 193]
                ]);
                const hair_color = choice([
                    [50, 30, 20], [20, 20, 20], [200, 150, 50], [150, 50, 50], [180, 180, 180], [88, 41, 0],
                    [255, 105, 180], [0, 191, 255], [50, 205, 50], [255, 165, 0], [148, 0, 211]
                ]);
                const hair_style = choice(['short', 'long', 'bald', 'mohawk']);
                const face_drawer = choice([drawCircleFace, drawRoundedRectFace]);
                const has_glasses = choice([true, false, false, false, false]);

                if (hair_style === 'long') {
                    ctx.fillStyle = rgb(hair_color);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, size * 0.5, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                const face_size = size * 0.8;
                const bounds = face_drawer(ctx, center, face_size, skin_color);

                if (hair_style === 'short') {
                    ctx.fillStyle = rgb(hair_color);
                    ctx.beginPath();
                    ctx.fillRect(bounds.x, bounds.y, bounds.width, bounds.height * 0.4);
                } else if (hair_style === 'mohawk') {
                    ctx.fillStyle = rgb(hair_color);
                    ctx.beginPath();
                    const mohawk_width = bounds.width * 0.3;
                    ctx.fillRect(bounds.center.x - mohawk_width / 2, bounds.y - bounds.height * 0.1, mohawk_width, bounds.height * 0.5);
                    ctx.fill();
                }

                const eye_info = drawEyes(ctx, bounds);
                drawMouth(ctx, bounds);

                if (has_glasses) {
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = Math.max(1, size/40);
                    ctx.beginPath();
                    ctx.moveTo(eye_info.left_eye_x + eye_info.eye_size, eye_info.eye_y);
                    ctx.lineTo(eye_info.right_eye_x - eye_info.eye_size, eye_info.eye_y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(eye_info.left_eye_x, eye_info.eye_y, eye_info.eye_size * 1.2, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(eye_info.right_eye_x, eye_info.eye_y, eye_info.eye_size * 1.2, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                return canvas;
            }

            const regenerateAllAvatars = () => {
                avatarCanvas.innerHTML = '';
                const style = window.getComputedStyle(avatarCanvas);
                const gap = parseFloat(style.gap) || 8;
                const padding = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
                const containerWidth = avatarCanvas.clientWidth - padding;
                const columns = 12;
                currentAvatarSize = (containerWidth - (gap * (columns - 1))) / columns;

                if (currentAvatarSize <= 0) return;

                for (let i = 0; i < 24; i++) {
                    const newAvatar = generateNPCAvatar(currentAvatarSize);
                    avatarCanvas.appendChild(newAvatar);
                }
            };

            generateBtn.addEventListener('click', () => {
                if (currentAvatarSize > 0) {
                    const newAvatar = generateNPCAvatar(currentAvatarSize);
                    avatarCanvas.appendChild(newAvatar);
                }
            });

            regenerateAllAvatars();

            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(regenerateAllAvatars, 250);
            });
        }
    </script>
</body>
</html> 